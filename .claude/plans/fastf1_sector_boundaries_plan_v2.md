# F1 Sector Boundary Reconstruction Plan v2  
_FastF1 → Optimized JSON → Three.js Sector-Colored Track_  

Author: _Generated by ChatGPT (updated with performance feedback)_  

Purpose:  
**Reconstruct sector 1/2/3 boundaries from FastF1 telemetry in Python, export them in a browser‑friendly format, and render a high‑performance sector-colored track in Three.js.**  

This version focuses on:  

- Smaller, columnar JSON payloads  
- Single-geometry rendering with vertex colors  
- More accurate sector boundary locations (linear interpolation)  
- Coordinate normalization and fast-loading considerations  

---

## 1. High-Level Flow

1. **Load session + laps with FastF1** (practice, qualifying, or race).  
2. **Pick a reference lap** (fastest valid lap for a driver).  
3. **Extract:**
   - Lap meta: `Sector1Time`, `Sector2Time`, `Sector3Time`
   - Position data: `Time`, `Distance`, `X`, `Y` (`get_pos_data()`)
4. **Compute sector boundary distances** using **linear interpolation** on telemetry samples.  
5. **Map distances → coordinates (X, Y)** precisely along the lap path.  
6. **Normalize coordinates** (center track at origin, optional uniform scale).  
7. **Downsample** the track points to a sensible resolution for UI maps.  
8. **Export a columnar JSON structure** (arrays of x, y, distance, sector).  
9. **In Three.js**, load JSON, build a **single BufferGeometry** with vertex colors and render the track in **one draw call**.  

---

## 2. Prerequisites

### 2.1 Python side

- Python 3.10+  
- `fastf1`  
- `pandas`  
- `numpy`  

Install:

```bash
pip install fastf1 pandas numpy
```

Enable FastF1 cache:

```python
import fastf1
fastf1.Cache.enable_cache("./fastf1_cache")
```

### 2.2 Frontend side

- Three.js (or React Three Fiber)  
- Ability to serve gzip/Brotli-compressed JSON over HTTP  

---

## 3. Selecting the Reference Lap

```python
import fastf1

session = fastf1.get_session(2024, "Monaco", "Q")
session.load(telemetry=True, laps=True)

# Pick fastest valid lap for a driver (e.g. VER)
laps_ver = session.laps.pick_driver("VER").pick_quicklaps()
ref_lap = laps_ver.pick_fastest()

print(ref_lap["LapTime"], ref_lap["Sector1Time"], ref_lap["Sector2Time"], ref_lap["Sector3Time"])
```

---

## 4. Getting Position Data

Use position telemetry; it typically has `X`, `Y`, and `Distance`:

```python
pos = ref_lap.get_pos_data()
# Columns: Time, X, Y, Z, Distance (usually)
print(pos.head())

# Normalize telemetry time to "time since lap start"
t0 = pos["Time"].iloc[0]
pos["LapTime"] = pos["Time"] - t0
```

If `Distance` is missing:

```python
pos = pos.add_distance()
```

---

## 5. Accurate Sector Boundary Distances (Linear Interpolation)

### 5.1 Sector end times

```python
import pandas as pd

s1_end_t = ref_lap["Sector1Time"]
s2_end_t = ref_lap["Sector1Time"] + ref_lap["Sector2Time"]
lap_end_t = ref_lap["LapTime"]
```

### 5.2 Helper: interpolate distance at a given lap time

Instead of simply snapping to the nearest telemetry sample (which can be off by several meters at race speed), we **linearly interpolate** between the surrounding samples.

```python
import numpy as np

def interp_distance_at_time(pos_df: pd.DataFrame, target: pd.Timedelta) -> float:
    times = pos_df["LapTime"].values
    dists = pos_df["Distance"].values

    # Convert Timedelta64 to float seconds for easier math
    times_s = times.astype("timedelta64[ns]").astype(np.float64) / 1e9
    target_s = target.to_timedelta64().astype(np.float64) / 1e9

    # Find index just after the target
    after_idx = np.searchsorted(times_s, target_s, side="right")
    if after_idx == 0:
        return float(dists[0])
    if after_idx >= len(times_s):
        return float(dists[-1])

    before_idx = after_idx - 1
    t0, t1 = times_s[before_idx], times_s[after_idx]
    d0, d1 = dists[before_idx], dists[after_idx]

    alpha = (target_s - t0) / (t1 - t0)
    return float(d0 + alpha * (d1 - d0))
```

### 5.3 Compute sector distances

```python
s1_dist = interp_distance_at_time(pos, s1_end_t)
s2_dist = interp_distance_at_time(pos, s2_end_t)
lap_dist = float(pos["Distance"].max())
```

Sector ranges (by distance):

- Sector 1: `0 → s1_dist`  
- Sector 2: `s1_dist → s2_dist`  
- Sector 3: `s2_dist → lap_dist`  

---

## 6. Coordinate Normalization (Centering & Scaling)

F1 coordinates can be large (e.g., ~15000, -2000). To avoid floating-point jitter far from the origin in Three.js, we **recenter and optionally scale** in Python.

```python
import numpy as np

xs = pos["X"].to_numpy(dtype=float)
ys = pos["Y"].to_numpy(dtype=float)

center_x = xs.mean()
center_y = ys.mean()

# recentre
xs_norm = xs - center_x
ys_norm = ys - center_y

# Optional: scale to a reasonable size for your scene
SCALE = 0.1  # tweak as desired
xs_norm *= SCALE
ys_norm *= SCALE
```

We’ll use `xs_norm`, `ys_norm` below instead of raw X/Y.

---

## 7. Assigning Sector Indices Per Point

```python
def sector_for_distance(d: float, s1: float, s2: float) -> int:
    if d <= s1:
        return 1
    elif d <= s2:
        return 2
    else:
        return 3

distances = pos["Distance"].to_numpy(dtype=float)
sectors = np.array([sector_for_distance(d, s1_dist, s2_dist) for d in distances], dtype=int)
```

---

## 8. Optional: Downsampling for UI Maps

You probably **don’t need 10,000 points** for a small 2D/3D UI track map. Downsample on the Python side to keep JSON tiny and parsing fast.

Simplest approach: distance-based thinning (keep a point only if you’ve moved more than _X_ meters since the last kept point).

```python
def downsample_by_distance(xs, ys, ds, secs, min_step=5.0):
    """Keep a subset of points such that distance spacing is >= min_step."""
    keep_indices = [0]
    last_d = ds[0]
    for i in range(1, len(ds)):
        if ds[i] - last_d >= min_step:
            keep_indices.append(i)
            last_d = ds[i]
    keep_indices.append(len(ds) - 1)

    keep_indices = np.unique(keep_indices)
    return xs[keep_indices], ys[keep_indices], ds[keep_indices], secs[keep_indices]

xs_ds, ys_ds, ds_ds, sectors_ds = downsample_by_distance(xs_norm, ys_norm, distances, sectors, min_step=5.0)
```

_For more aggressive simplification, you could use Ramer–Douglas–Peucker (RDP), but distance-based thinning is often enough for telemetry maps._

---

## 9. Columnar JSON Export (Frontend-Friendly)

Instead of an array of objects, we export **columnar arrays** so the browser does not have to parse repeated keys thousands of times.

```python
import json
from pathlib import Path

export = {
    "track": {
        "name": session.event["EventName"],
        "year": int(session.event["Year"]),
        "session": str(session.name),
        "driver": str(ref_lap["Driver"]),
        "length_m": lap_dist,
        "sectorDistances": [s1_dist, s2_dist, lap_dist],
        # Columnar arrays
        "x": xs_ds.tolist(),
        "y": ys_ds.tolist(),
        "distance": ds_ds.tolist(),
        "sector": sectors_ds.tolist()
    }
}

out_path = Path("monaco_q_ver_track_v2.json")
out_path.write_text(json.dumps(export, separators=(",", ":")))  # compact JSON
print("Wrote", out_path)
```

### Why columnar?

- Lower file size (no repeated `{ "x": ...}` structure).  
- Faster to parse.  
- You can feed arrays directly into `THREE.BufferAttribute` without building intermediate objects.

---

## 10. Three.js Integration (Single Geometry + Vertex Colors)

### 10.1 Loading the JSON

```js
import * as THREE from 'three';

async function loadTrackJson(url) {
  const res = await fetch(url);
  const data = await res.json();
  return data.track;
}
```

### 10.2 Building a single BufferGeometry

We create one geometry and use a **color attribute per vertex** based on the sector index. This avoids tiny gaps between sectors and keeps it at **one draw call**.

```js
function buildTrackGeometry(track) {
  const xs = track.x;
  const ys = track.y;
  const sectors = track.sector;

  const vertexCount = xs.length;
  const positions = new Float32Array(vertexCount * 3);
  const colors = new Float32Array(vertexCount * 3);

  const colorSector1 = new THREE.Color(0x00e5ff); // cyan
  const colorSector2 = new THREE.Color(0xb700ff); // purple
  const colorSector3 = new THREE.Color(0xffd400); // yellow

  for (let i = 0; i < vertexCount; i++) {
    const x = xs[i];
    const y = ys[i];
    const z = 0;

    const offset = i * 3;
    positions[offset + 0] = x;
    positions[offset + 1] = y;
    positions[offset + 2] = z;

    let c;
    if (sectors[i] === 1) c = colorSector1;
    else if (sectors[i] === 2) c = colorSector2;
    else c = colorSector3;

    colors[offset + 0] = c.r;
    colors[offset + 1] = c.g;
    colors[offset + 2] = c.b;
  }

  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
  geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

  return geometry;
}

function createTrackLine(geometry) {
  const material = new THREE.LineBasicMaterial({
    vertexColors: true,
    linewidth: 2
  });
  return new THREE.Line(geometry, material);
}
```

Usage:

```js
async function init(scene) {
  const track = await loadTrackJson('/assets/monaco_q_ver_track_v2.json');
  const geometry = buildTrackGeometry(track);
  const line = createTrackLine(geometry);
  scene.add(line);
}
```

This renders the entire track polyline with sector-based colors in **one continuous line**.

---

## 11. Fast-Loading Checklist

To keep things snappy in the browser:

### ✅ 1. Gzip/Brotli Compression (Server)

- Serve JSON with gzip or Brotli compression enabled (e.g., in nginx, Vercel, Cloudflare, etc.).  
- Columnar JSON + gzip usually shrinks to **10–20%** of the original size.

### ✅ 2. Downsample (Python)

- Downsample to ~1–3k points per lap for UI maps (before export).  
- Use `downsample_by_distance` or RDP for more aggressive reduction.  

### ✅ 3. Asset Preloading (Frontend)

- While your HUD/React UI mounts, start fetching track JSON:  

```js
// Example using a simple hook
import { useEffect, useState } from 'react';

function useTrack(url) {
  const [track, setTrack] = useState(null);

  useEffect(() => {
    let cancelled = false;
    loadTrackJson(url).then(data => {
      if (!cancelled) setTrack(data);
    });
    return () => { cancelled = true; };
  }, [url]);

  return track;
}
```

- Show a minimal loading state; attach geometry only when `track` is ready.

---

## 12. End-to-End Outline (v2)

1. **Python/FastF1**
   - Load session → pick reference lap.  
   - Extract `pos = ref_lap.get_pos_data()`.  
   - Compute `s1_end_t`, `s2_end_t`, `lap_end_t`.  
   - Use **linear interpolation** to compute `s1_dist`, `s2_dist`.  
   - Normalize X/Y to center track near origin and scale.  
   - Assign sector index per point based on distance.  
   - Optionally downsample by distance.  
   - Export **columnar JSON** (`x`, `y`, `distance`, `sector`).  

2. **Backend / Hosting**
   - Serve JSON with gzip/Brotli.  
   - Optionally embed it into your asset pipeline (`/assets/tracks/...`).  

3. **Three.js / React Three Fiber**
   - Preload JSON during UI initialization.  
   - Build a single `BufferGeometry` and `Line` with per-vertex colors.  
   - Optionally animate a “car dot” along the polyline using the `distance` array.  

4. **Further Enhancements**
   - Add a second attribute (e.g., `deltaTime`) for gradient coloring inside sectors.  
   - Switch from `LineBasicMaterial` to a custom shader for glow, falloff, or HUD effects.  
   - Overlay multiple laps (different drivers) using separate geometries but same JSON columnar pattern.  

---

## 13. Reference: Minimal Python Export Script (v2)

```python
import json
from pathlib import Path

import fastf1
import numpy as np
import pandas as pd

fastf1.Cache.enable_cache("./fastf1_cache")


def interp_distance_at_time(pos_df: pd.DataFrame, target: pd.Timedelta) -> float:
    times = pos_df["LapTime"].values
    dists = pos_df["Distance"].values

    times_s = times.astype("timedelta64[ns]").astype(np.float64) / 1e9
    target_s = target.to_timedelta64().astype(np.float64) / 1e9

    after_idx = np.searchsorted(times_s, target_s, side="right")
    if after_idx == 0:
        return float(dists[0])
    if after_idx >= len(times_s):
        return float(dists[-1])

    before_idx = after_idx - 1
    t0, t1 = times_s[before_idx], times_s[after_idx]
    d0, d1 = dists[before_idx], dists[after_idx]

    alpha = (target_s - t0) / (t1 - t0)
    return float(d0 + alpha * (d1 - d0))


def sector_for_distance(d: float, s1: float, s2: float) -> int:
    if d <= s1:
        return 1
    elif d <= s2:
        return 2
    else:
        return 3


def downsample_by_distance(xs, ys, ds, secs, min_step=5.0):
    keep_indices = [0]
    last_d = ds[0]
    for i in range(1, len(ds)):
        if ds[i] - last_d >= min_step:
            keep_indices.append(i)
            last_d = ds[i]
    keep_indices.append(len(ds) - 1)
    keep_indices = np.unique(keep_indices)

    return xs[keep_indices], ys[keep_indices], ds[keep_indices], secs[keep_indices]


def export_track_with_sectors_v2(year: int, gp: str, session_name: str, driver: str, out_file: str):
    session = fastf1.get_session(year, gp, session_name)
    session.load(telemetry=True, laps=True)

    laps = session.laps.pick_driver(driver).pick_quicklaps()
    ref_lap = laps.pick_fastest()

    pos = ref_lap.get_pos_data()
    t0 = pos["Time"].iloc[0]
    pos["LapTime"] = pos["Time"] - t0

    s1_end_t = ref_lap["Sector1Time"]
    s2_end_t = ref_lap["Sector1Time"] + ref_lap["Sector2Time"]
    lap_end_t = ref_lap["LapTime"]

    s1_dist = interp_distance_at_time(pos, s1_end_t)
    s2_dist = interp_distance_at_time(pos, s2_end_t)
    lap_dist = float(pos["Distance"].max())

    xs = pos["X"].to_numpy(dtype=float)
    ys = pos["Y"].to_numpy(dtype=float)
    ds = pos["Distance"].to_numpy(dtype=float)

    center_x = xs.mean()
    center_y = ys.mean()
    xs = xs - center_x
    ys = ys - center_y
    SCALE = 0.1
    xs *= SCALE
    ys *= SCALE

    sectors = np.array([sector_for_distance(d, s1_dist, s2_dist) for d in ds], dtype=int)

    xs_ds, ys_ds, ds_ds, sectors_ds = downsample_by_distance(xs, ys, ds, sectors, min_step=5.0)

    export = {
        "track": {
            "name": session.event["EventName"],
            "year": int(session.event["Year"]),
            "session": str(session.name),
            "driver": driver,
            "length_m": lap_dist,
            "sectorDistances": [s1_dist, s2_dist, lap_dist],
            "x": xs_ds.tolist(),
            "y": ys_ds.tolist(),
            "distance": ds_ds.tolist(),
            "sector": sectors_ds.tolist()
        }
    }

    Path(out_file).write_text(json.dumps(export, separators=(",", ":")))
    print(f"Exported optimized track JSON to {out_file}")


if __name__ == "__main__":
    export_track_with_sectors_v2(2024, "Monaco", "Q", "VER", "monaco_q_ver_track_v2.json")
```

---

This v2 plan should give you **accurate sector boundaries**, **lean JSON payloads**, and a **high-performance Three.js implementation** that fits nicely into your React HUD/telemetry UI.
